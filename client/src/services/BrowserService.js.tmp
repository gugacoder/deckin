import router from '@/router'; 
import { sanitizeEntity, isKindOf } from '@/helpers/EntityOperations.js'

function fetchEntity(path, payload) {
  return new Promise((resolve, reject) => {
    path = makePath(tokenizePath(path))
    
    let options = {
      headers: new Headers()
    }
    
    let identity = sessionStorage.getItem('identity')
    if (identity && identity.token) {
      options.headers.append('Authorization', `Token ${identity.token}`)
    }

    if (payload) {
      options.method = 'post'
      options.body = JSON.stringify(payload)
    }

    fetch(path, options)
      .then(response => response.json())
      .then(data => sanitizeEntity(data))
      .then(entity => resolve(entity))
      .catch(error => reject(error))
  })  
}

function getEntity(path, payload) {
  return new Promise((resolve, reject) => {
    fetchEntity(path, payload).then(entity => {

      if (entity.meta && entity.meta.identity) {
        sessionStorage.setItem('identity', entity.meta.identity)
      }

      if (entity.meta && entity.meta.go) {
        let link = entity.links.filter(link => link.rel === entity.meta.go)[0];
        if (link) {
          console.log(link.href)
          return getEntity(link.href, link.data).then(resolve).catch(reject)
        }
      }

      if (isKindOf(entity, 'paper')) {
        sessionStorage.setItem('paper.content', entity)
        router.push(makeRoute(path))
      }
      
      resolve && resolve(entity)
    }).catch(error => reject && reject(error)) 
  })
}

function makePath(path) {
  let tokens = Array.isArray(path) ? path : tokenizePath(path)
  return `/!/${tokens.join('/')}`
}

function makeRoute(path) {
  let tokens = Array.isArray(path) ? path : tokenizePath(path)
  return `/Papers/${tokens.join('/')}`
}

function tokenizePath(path) {
  let tokens

  if (typeof path === 'string') {
    // Formato: "/!/Catalog/Paper/Actions/Keys...
    let parts = path.split('/').filter(x => x !== '').slice(1)
    tokens = [
      // catalogName
      parts.shift(),
      // paperName
      parts.shift(),
      // paperAction
      parts.shift(),
      // paperKeys
      ...parts
    ]
  } else {
    tokens = [
      path.catalog || path.catalogName,
      path.name || path.paperName,
      path.action || path.paperAction,
      ...(path.keys || path.paperKeys)
    ]
  }
  return tokens
}

export default {
  fetchEntity,
  getEntity,
  tokenizePath,
  makePath,
  makeRoute,
}